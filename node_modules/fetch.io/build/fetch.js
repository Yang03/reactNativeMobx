'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assign = Object.assign;

/**
 * Request
 */

var Request = function () {
  function Request(method, url) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Request);

    method = method.toUpperCase();
    if (typeof url !== 'string') {
      throw new TypeError('invalid url');
    }

    var options = this.options = assign({}, {
      mode: 'cors',
      cache: 'no-cache',
      credentials: 'include',
      headers: {},
      query: {}
    }, opts);

    var prefix = options.prefix || '';
    this.url = prefix + url;

    options.method = method;

    // fetch will normalize the headers
    var headers = options.headers;

    for (var h in headers) {
      if (h !== h.toLowerCase()) {
        headers[h.toLowerCase()] = headers[h];
        delete headers[h];
      }
    }
  }

  /**
   * Set Options
   *
   * Examples:
   *
   *   .config('credentials', 'omit')
   *   .config({ credentials: 'omit' })
   *
   * @param {String|Object} key
   * @param {Any} value
   * @return {Request}
   */


  _createClass(Request, [{
    key: 'config',
    value: function config(key, value) {
      var options = this.options;

      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
        for (var k in key) {
          options[k] = key[k];
        }
      } else {
        options[key] = value;
      }

      return this;
    }

    /**
     * Set header
     *
     * Examples:
     *
     *   .set('Accept', 'application/json')
     *   .set({ Accept: 'application/json' })
     *
     * @param {String|Object} key
     * @param {String} value
     * @return {Request}
     */

  }, {
    key: 'set',
    value: function set(key, value) {
      var headers = this.options.headers;

      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
        for (var k in key) {
          headers[k.toLowerCase()] = key[k];
        }
      } else {
        headers[key.toLowerCase()] = value;
      }

      return this;
    }

    /**
     * Set Content-Type
     *
     * @param {String} type
     */

  }, {
    key: 'type',
    value: function type(_type) {
      switch (_type) {
        case 'json':
          _type = 'application/json';
          break;
        case 'form':
        case 'urlencoded':
          _type = 'application/x-www-form-urlencoded';
          break;
      }

      this.options.headers['content-type'] = _type;

      return this;
    }

    /**
     * Add query string
     *
     * @param {Object} object
     * @return {Request}
     */

  }, {
    key: 'query',
    value: function query(object) {
      var query = this.options.query;

      for (var i in object) {
        query[i] = object[i];
      }

      return this;
    }

    /**
     * Send data
     *
     * Examples:
     *
     *   .send('name=hello')
     *   .send({ name: 'hello' })
     *
     * @param {String|Object} data
     * @return {Request}
     */

  }, {
    key: 'send',
    value: function send(data) {
      var type = this.options.headers['content-type'];

      if (isObject(data) && isObject(this._body)) {
        // merge body
        for (var key in data) {
          this._body[key] = data[key];
        }
      } else if (typeof data === 'string') {
        if (!type) {
          this.options.headers['content-type'] = type = 'application/x-www-form-urlencoded';
        }

        if (type.indexOf('x-www-form-urlencoded') !== -1) {
          this._body = this._body ? this._body + '&' + data : data;
        } else {
          this._body = (this._body || '') + data;
        }
      } else {
        this._body = data;
      }

      // default to json
      if (!type) {
        this.options.headers['content-type'] = 'application/json';
      }

      return this;
    }

    /**
     * Append formData
     *
     * Examples:
     *
     *   .append(name, 'hello')
     *
     * @param {String} key
     * @param {String} value
     * @return {Request}
     */

  }, {
    key: 'append',
    value: function append(key, value) {
      if (!(this._body instanceof FormData)) {
        this._body = new FormData();

        if (isNode()) {
          var _headers = this._body.getHeaders();
          if (_headers && _headers['content-type']) {
            this.options.headers['content-type'] = _headers['content-type'];
          }
        }
      }

      this._body.append(key, value);

      return this;
    }
  }, {
    key: 'promise',
    value: function promise() {
      var options = this.options;
      var url = this.url;
      var beforeRequest = options.beforeRequest,
          afterResponse = options.afterResponse;


      try {
        if (['GET', 'HEAD', 'OPTIONS'].indexOf(options.method.toUpperCase()) === -1) {
          if (this._body instanceof FormData) {
            options.body = this._body;
          } else if (isObject(this._body) && isJsonType(options.headers['content-type'])) {
            options.body = JSON.stringify(this._body);
          } else if (isObject(this._body)) {
            options.body = stringify(this._body);
          } else {
            options.body = this._body;
          }
        } else {
          delete options.headers['content-type'];
        }

        if (isObject(options.query)) {
          if (url.indexOf('?') >= 0) {
            url += '&' + stringify(options.query);
          } else {
            url += '?' + stringify(options.query);
          }
        }

        if (beforeRequest) {
          var canceled = beforeRequest(url, options.body);
          if (canceled === false) {
            return Promise.reject(new Error('request canceled by beforeRequest'));
          }
        }
      } catch (e) {
        return Promise.reject(e);
      }

      if (afterResponse) {
        return fetch(url, options).then(function (res) {
          afterResponse(res);
          return res;
        });
      }

      return fetch(url, options);
    }
  }, {
    key: 'then',
    value: function then(resolve, reject) {
      return this.promise().then(resolve, reject);
    }
  }, {
    key: 'catch',
    value: function _catch(reject) {
      return this.promise().catch(reject);
    }
  }, {
    key: 'json',
    value: function json() {
      var _this = this;

      var strict = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      return this.promise().then(function (res) {
        return res.json();
      }).then(function (json) {
        if (strict && !isObject(json)) {
          throw new TypeError('response is not strict json');
        }

        if (_this.options.afterJSON) {
          _this.options.afterJSON(json);
        }

        return json;
      });
    }
  }, {
    key: 'text',
    value: function text() {
      return this.promise().then(function (res) {
        return res.text();
      });
    }
  }]);

  return Request;
}();

/**
 * Private utils
 */

function isObject(obj) {
  // not null
  return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

function isJsonType(contentType) {
  return contentType && contentType.indexOf('application/json') === 0;
}

function stringify(obj) {
  return Object.keys(obj).map(function (key) {
    return key + '=' + obj[key];
  }).join('&');
}

function isNode() {
  return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && process.title === 'node';
}

/**
 * Fetch
 */

function Fetch(options) {
  if (!(this instanceof Fetch)) {
    return new Fetch(options);
  }

  this.options = options || {};
}

var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

methods.forEach(function (method) {
  method = method.toLowerCase();
  Fetch.prototype[method] = function (url) {
    var opts = assign({}, this.options);
    return new Request(method, url, opts);
  };
});

/**
 * export
 */

module.exports = Fetch;